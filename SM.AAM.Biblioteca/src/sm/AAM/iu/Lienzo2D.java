/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sm.AAM.iu;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Cursor;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import static java.awt.event.InputEvent.BUTTON3_MASK;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;
import sm.AAM.graficos.Atributo;
import sm.AAM.graficos.Borde;
import sm.AAM.graficos.Curva;
import sm.AAM.graficos.Elipse;
import sm.AAM.graficos.Forma;
import sm.AAM.graficos.Linea;
import sm.AAM.graficos.Poligono;
import sm.AAM.graficos.Rectangulo;
import sm.AAM.graficos.PoligonoAbierto;
import sm.AAM.graficos.RectanguloRedondeado;
import sm.AAM.graficos.Relleno;
import sm.AAM.graficos.TrazoLibre;

/**
 * Esta clase define objetos que contienen un panel donde dibujar
 *
 * @author Antonio
 */
public class Lienzo2D extends javax.swing.JPanel {
    
    private Color color;
    private String forma;
    private boolean mover_figura;
    private boolean transparente;
    private boolean alisado;
    private Point2D puntoInicio;
    private Point2D Arco;
    private Curva curva;
    private Forma figura;
    private Shape contorno;
    private int grosor;
    private int tipoBorde;
    private boolean esta_relleno;
    private List<Forma> vShape;
    private RenderingHints rh;
    private Composite comp;
    private Forma figuraSeleccionada;
    private Borde bordeInicial;
    private int etapaCurva;
    private int clickeando;
    private int clickeandoPoligonoAbiero;
    private Poligono poligono;
    private PoligonoAbierto poligonoAbierto;
    private Point2D distancia;
    private static float[] dash1 = {4.0f};
    private static Borde strokeClip;
    private Relleno relleno;

    /**
     * Creates new form Lienzo2D
     */
    public Lienzo2D() {
        initComponents();
        color = Color.BLACK;
        forma = "Punto";
        mover_figura = false;
        transparente = false;
        alisado = false;
        puntoInicio = null;
        Arco = new Point2D.Double(20, 20);
        grosor = 1;
        tipoBorde = 0;
        esta_relleno = false;
        vShape = new ArrayList();
        rh = null;
        comp = null;
        bordeInicial = new Borde(1.0f);
        etapaCurva = 0;
        clickeando = 0;
        clickeandoPoligonoAbiero = 0;
        poligono = null;
        poligonoAbierto = null;
        distancia = new Point2D.Double(0, 0);
        strokeClip = new Borde(2.0F, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER,
                1.0f, dash1, 0.0f);
        contorno = this.getBounds();
    }

    /**
     * Crea una Forma y la devuelve
     *
     * @param puntoInicio - Punto de comienzo de una figura
     * @return - Devuelve una Forma
     */
    private Forma createShape(Point2D puntoInicio) {
        Forma figura = null;
        figuraSeleccionada = null;
        Point2D puntoFinal = new Point2D.Double(0, 0);
        if (puntoInicio != null) {
            if (this.forma == "Linea") {
                Linea linea = new Linea(puntoInicio, puntoInicio);
                figura = linea;
            } else if (this.forma == "Punto") {
                Linea punto = new Linea(this.puntoInicio, this.puntoInicio);
                figura = punto;
            } else if (this.forma == "Rectangulo") {
                Rectangulo rectangulo = new Rectangulo(puntoInicio, puntoFinal);
                figura = rectangulo;
            } else if (this.forma == "Elipse") {
                Elipse elipse = new Elipse(puntoInicio, puntoFinal);
                figura = elipse;
            } else if (this.forma == "Curva") {
                this.etapaCurva++;
                if (this.etapaCurva == 1) {
                    curva = new Curva(puntoInicio);
                    figura = curva;
                } else if (this.etapaCurva == 2) {
                    curva.setPC(puntoInicio);
                    figura = curva;
                    
                }
            } else if (this.forma == "RectanguloRedondeado") {
                RectanguloRedondeado rectanguloRedondeado = new RectanguloRedondeado(puntoInicio, puntoFinal, this.Arco, bordeInicial);
                figura = rectanguloRedondeado;
            } else if (this.forma == "TrazoLibre") {
                TrazoLibre trazoLibre = new TrazoLibre(puntoInicio);
                figura = trazoLibre;
            }
        }
        
        return figura;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(255, 255, 255));
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setPreferredSize(new java.awt.Dimension(300, 300));
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
/**
     * Cuando presionas con el ratón, envías un punto a CreateShape, en cuya
     * función creas la forma y añadimos la forma a una lista de formas.
     *
     * @param evt - Evento producido por el ratón
     */
    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        if (this.mover_figura && this.forma != "TrazoLibre") {
            this.setCursor(new Cursor(Cursor.MOVE_CURSOR));
            this.figuraSeleccionada = getSelectedShape(evt.getPoint());
            if (figuraSeleccionada != null) {
                double x = this.figuraSeleccionada.getP1().getX();
                double y = this.figuraSeleccionada.getP1().getY();
                this.distancia.setLocation(x - evt.getPoint().getX(), y - evt.getPoint().getY());
            }
            
        } else if (this.forma != "Poligono" && this.forma != "PoligonoAbierto") {
            this.setCursor(new Cursor(Cursor.CROSSHAIR_CURSOR));
            this.puntoInicio = evt.getPoint();
            this.figura = this.createShape(evt.getPoint());
            vShape.add(this.figura);
            if (relleno != null) {
                this.setRelleno(relleno);
            }
            this.setStroke(tipoBorde);
        }
        
        repaint();
    }//GEN-LAST:event_formMousePressed
    /**
     * Ocurre cuando se suelta un botón en el Mouse. En caso de que sea una
     * curva se reiniciará las etapas de la curva.
     *
     * @param evt - Evento producido por el ratón
     */
    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        this.setCursor(Cursor.getDefaultCursor());
        this.formMouseDragged(evt);
        if (this.etapaCurva == 2) {
            this.etapaCurva = 0;
        }
        
        figura = null;

    }//GEN-LAST:event_formMouseReleased
    /**
     * Ocurre cuando el boton del raton se oprime mientras el cursor esta sobre
     * un componente y se mueve mientras se mantiene presionado. En el caso de
     * que se mover figura, mientras esta presionado se mueve la figura. En caso
     * contrarío se va actualizando el tamaño de la figura
     *
     * @param evt - Evento producido por el ratón
     */
    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if (this.mover_figura && this.forma != "TrazoLibre") {
            if (this.figuraSeleccionada != null) {
                Point2D corner = evt.getPoint();
                double coordenadaX = corner.getX();
                double coordenadaY = corner.getY();
                this.figuraSeleccionada.setLocation(new Point2D.Double(corner.getX() + this.distancia.getX(), corner.getY() + this.distancia.getY()));
            }
        } else if (this.forma == "Curva") {
            if (this.etapaCurva == 1) {
                Point2D pFinal = evt.getPoint();
                this.figura.setGeometry(pFinal);
            } else if (this.etapaCurva == 2) {
                Point2D pIntermedio = evt.getPoint();
                curva.setPC(pIntermedio);
            }
        } else if (this.forma != "Punto" && this.forma != "Poligono" && this.forma != "PoligonoAbierto") {
            this.figura.setGeometry(evt.getPoint());
            
        }
        repaint();
    }//GEN-LAST:event_formMouseDragged
    /**
     * Se llama cuando se oprime y se suelta un botón en el mouse. En este
     * método creamos el polígono
     *
     * @param evt - Evento producido por el ratón
     */
    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        if (!this.mover_figura) {
            if (this.forma == "Poligono" && !evt.isMetaDown()) {
                if (this.clickeando == 0) {
                    poligono = new Poligono(evt.getPoint());
                    this.clickeando++;
                    figura = poligono;
                    if (relleno != null) {
                        this.setRelleno(relleno);
                    }
                    this.setStroke(tipoBorde);
                    vShape.add(this.figura);
                    
                } else {
                    poligono.addPoint(evt.getPoint());
                    figura = poligono;
                    if (relleno != null) {
                        this.setRelleno(relleno);
                    }
                    this.setStroke(tipoBorde);
                }
            }
            if (this.forma == "PoligonoAbierto" && !evt.isMetaDown()) {
                if (this.clickeandoPoligonoAbiero == 0) {
                    poligonoAbierto = new PoligonoAbierto(evt.getPoint());
                    this.clickeandoPoligonoAbiero++;
                    figura = poligonoAbierto;
                    if (relleno != null) {
                        this.figura.setAtributo(relleno);
                    }
                    this.setStroke(tipoBorde);
                    vShape.add(this.figura);
                    
                } else {
                    poligonoAbierto.addPoint(evt.getPoint());
                    figura = poligonoAbierto;
                    if (relleno != null) {
                        this.setRelleno(relleno);
                    }
                    this.setStroke(tipoBorde);
                }
            }
            if (evt.getModifiers() == BUTTON3_MASK) {
                if (this.forma == "Poligono") {
                    clickeando = 0;
                    figura = null;
                }
                if (this.forma == "PoligonoAbierto") {
                    clickeandoPoligonoAbiero = 0;
                    figura = null;
                }
            }
        } else {
            if (this.forma == "Poligono") {
                clickeando = 0;
                figura = null;
            }
            if (this.forma == "PoligonoAbierto") {
                clickeandoPoligonoAbiero = 0;
                figura = null;
            }
        }
    }//GEN-LAST:event_formMouseClicked
    /**
     * Pinta en el lienzo las Formas y graphics
     *
     * @param g - Graphics de la imagen
     */
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        Graphics2D g2d = (Graphics2D) g;
        if (contorno != null) {
            strokeClip.aplicar(g2d);
            g2d.clip(contorno);
            g2d.draw(contorno);
        }
        for (Forma s : vShape) {
            s.draw(g2d);
        }
    }

    /**
     * Establece la forma a dibujar
     *
     * @param forma nombre de la forma
     */
    public void setForma(String forma) {
        this.forma = forma;
    }

    /**
     * Método que establece el color del trazo
     *
     * @param color - color del trazo
     */
    public void setColorTrazo(Color color) {
        List<Atributo> atributos = new ArrayList();
        Forma figuraColor = null;
        this.color = color;
        if (figura != null) {
            figuraColor = this.figura;
        } else {
            figuraColor = this.figuraSeleccionada;
        }
        if (figuraColor != null) {
            atributos = figuraColor.getAtributos();
            for (Atributo s : atributos) {
                if (s instanceof Borde) {
                    ((Borde) s).setColor(this.color);
                }
            }
            repaint();
        }
    }

    /**
     * Establece el grosor del trazo
     *
     * @param grosor - Tamaño del ancho de la línea
     */
    public void setGrosor(int grosor) {
        List<Atributo> atributos;
        Forma figuraBorde = null;
        this.grosor = grosor;
        if (figura != null) {
            figuraBorde = this.figura;
        } else {
            figuraBorde = this.figuraSeleccionada;
        }
        if (figuraBorde != null) {
            atributos = figuraBorde.getAtributos();
            for (int i = 0; i < atributos.size(); i++) {
                if (atributos.get(i) instanceof Borde) {
                    ((Borde) atributos.get(i)).setGrosor(grosor);
                }
            }
            repaint();
        }
    }

    /**
     * Método encargado de renderizar los bordes de la figura.
     *
     * @param alisado - Booleano que nos indica si esta marcada la casilla de
     * alisar o no.
     */
    public void setAlisar(boolean alisado) {
        List<Atributo> atributos = new ArrayList();
        Forma figuraAlisada = null;
        if (alisado) {
            this.alisado = true;
            this.rh = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        } else {
            this.rh = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
            this.alisado = false;
        }
        if (figura != null) {
            figuraAlisada = this.figura;
        } else {
            figuraAlisada = this.figuraSeleccionada;
        }
        if (figuraAlisada != null) {
            atributos = figuraAlisada.getAtributos();
            for (Atributo s : atributos) {
                s.setRenderizacion(rh);
            }
            repaint();
        }
        
    }

    /**
     * Método encargado de establecer el trazo de la figura.
     *
     * @param tipoBorde - Tipo de borde que deseas asignar a la forma
     */
    public void setStroke(int tipoBorde) {
        float dash1[] = {4.0f};
        Borde bordeFinal = null;
        RenderingHints render = null;
        Composite comp = null;
        this.tipoBorde = tipoBorde;
        List<Atributo> atributos = new ArrayList();
        Forma figuraBorde = null;
        if (figura != null) {
            figuraBorde = this.figura;
        } else {
            figuraBorde = this.figuraSeleccionada;
        }
        if (tipoBorde == 0) {
            bordeFinal = new Borde(this.grosor);
        } else if (tipoBorde == 1) {
            bordeFinal = new Borde(this.grosor, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, dash1);
        }
        if (figuraBorde != null) {
            atributos = figuraBorde.getAtributos();
            for (int i = 0; i < atributos.size(); i++) {
                if (atributos.get(i) instanceof Borde) {
                    color = ((Borde) atributos.get(i)).getColor();
                    render = atributos.get(i).getRenderizacion();
                    comp = atributos.get(i).getTransparencia();
                    atributos.remove(i);
                }
            }
            if(this.forma == "Punto"){
                Borde borde = new Borde(this.grosor);
                bordeFinal = borde;
            }
            bordeFinal.setRenderizacion(render);
            bordeFinal.setTransparencia(comp);
            bordeFinal.setColor(color);
            atributos.add(bordeFinal);           
        }
        repaint();
    }

    /**
     * Devuelve el color del trazo
     *
     * @return - Devuelve un color
     */
    public Color getColor() {
        return this.color;
    }

    /**
     * Método encargado de activar o desactivar mover forma
     *
     * @param editar - Booleano que nos indica si esta marcada la casilla de
     * editar o no.
     */
    public void setEditar(boolean editar) {
        if (editar) {
            this.mover_figura = true;
        } else {
            this.figuraSeleccionada = null;
            this.mover_figura = false;
        }
    }

    /**
     * Devuelve el nombre de la forma que estamos dibujando
     *
     * @return - Devuelve un string con el nombre de la forma
     */
    public String getForma() {
        return this.forma;
    }

    /**
     * Devuelve si esta activado el modo editar
     *
     * @return - Devuelve true si el modo editar esta seleccionado y false si no
     * lo está
     */
    public boolean getEditar() {
        return this.mover_figura;
    }

    /**
     * Devuelve si esta activada la transparencia
     *
     * @return - Devuelve true si el modo transparencia esta activo y false si
     * no lo está
     */
    public boolean estaTransparente() {
        return this.transparente;
    }

    /**
     * Devuelve el último grosor seleccionado
     *
     * @return - Devuelve un int con el grosor de la línea
     */
    public int getGrosor() {
        return this.grosor;
    }

    /**
     * Cambia el estado de la transparencia
     *
     * @param transparencia - Booleano que indica el estado de la transparencia
     */
    public void setTransparencia(boolean transparencia) {
        this.transparente = transparencia;
    }

    /**
     * Devuelve si esta activo o no el alisado
     *
     * @return Devuelve true si el modo alisado esta activo y false si no lo
     * está
     */
    public boolean estaAlisado() {
        return this.alisado;
    }

    /**
     * Cambia el estado del alisado
     *
     * @param alisado - Booleano que indica el estado del alisado
     */
    public void setAlisado(boolean alisado) {
        this.alisado = alisado;
    }

    /**
     * Devuelve la figura seleccionada
     *
     * @return Devuelve la forma última
     */
    public Forma getFigura() {
        if (figura != null) {
            return this.figura;
        } else {
            return this.figuraSeleccionada;
        }
    }

    /**
     * Devuelve si la forma esta rellena
     *
     * @return - Devuelve true si la forma esta rellena
     */
    public boolean estaRelleno() {
        return this.esta_relleno;
    }

    /**
     * Establece un relleno
     *
     * @param relleno
     */
    public void setRelleno(Relleno relleno) {
        List<Atributo> atributos = new ArrayList();
        RenderingHints render = null;
        Composite comp = null;
        Forma figuraRelleno = null;
        if (figura != null) {
            figuraRelleno = this.figura;
        } else {
            figuraRelleno = this.figuraSeleccionada;
        }
        
        if (relleno != null && figuraRelleno != null) {
            atributos = figuraRelleno.getAtributos();            
            for (int i = 0; i < atributos.size(); i++) {
                if (atributos.get(i) instanceof Relleno) {
                    render = atributos.get(i).getRenderizacion();
                    comp = atributos.get(i).getTransparencia();
                    atributos.remove(i);
                }
            }
            relleno.setRenderizacion(render);
            relleno.setTransparencia(comp);
            figuraRelleno.setAtributo(relleno);
            
        }
        this.relleno= relleno;
    }

    /**
     * Devuelve la forma, que está dentro del punto señalado
     *
     * @param p punto donde quieres seleccionar la forma que hay
     * @return - Devuelve la forma seleccionada
     */
    private Forma getSelectedShape(Point2D p) {
        Forma figura = null;
        for (Forma s : vShape) {
            if (s.contains(p)) {
                figura = s;
            }
        }
        return figura;
    }

    /**
     * Devuelve el tipo de trazo
     *
     * @return Devuelve un int con el valor del tipo del trazo
     */
    public int getTrazo() {
        return this.tipoBorde;
    }

    /**
     * Asigna al contorno el tamaño de la figura
     *
     * @param figura - Figura con el tamaño de la imagen
     */
    public void setImagen(Shape figura) {
        this.contorno = figura;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
